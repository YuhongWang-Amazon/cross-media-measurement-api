syntax = "proto3";

package wfa.measurement.api.v1alpha;

import "google/protobuf/timestamp.proto";

option java_package = "org.wfanet.measurement.api.v1alpha";
option java_multiple_files = true;
option java_outer_classname = "GlobalComputationStatusUpdateProto";

message GlobalComputationStatusUpdate {
  message Key {
    string global_computation_id = 1;
    string global_computation_status_update_id = 2;
  }
  Key key = 1;

  // A non-trusted identifier for the creator of this status update. This is
  // for debugging purposes and can include additional information beyond what
  // is provided by authentication, e.g. the replica number of the task creating
  // this status update.
  string self_reported_identifier = 2;

  // Details on the computation's progress.
  StageDetails stage_details = 3;

  // Free-form human-readable status update message.
  string update_message = 4;

  // Only populated if an error occurred during processing.
  ErrorDetails error_details = 5;

  // Output only. When the GlobalComputationStatusUpdate was created.
  google.protobuf.Timestamp create_time = 6;

  message StageDetails {
    // Each MPC algorithm has a concept of "stages" of the computation. Since
    // there may be different algorithms with different stages, we use an int64
    // field here instead of a proto enum.
    oneof stage {
      SketchAggregationMpc.SketchAggregationStage sketch_aggregation_stage = 1;
    }

    // When the stage started.
    google.protobuf.Timestamp start = 2;

    // If processing a stage fails, it may be retried. This field holds the
    // number of times the stage has been attempted. The first attempt should
    // populate this with 1, not 0.
    int64 attempt_number = 3;
  }

  message ErrorDetails {
    google.protobuf.Timestamp error_time = 1;
    ErrorType error_type = 2;

    // Human-readable error message. This should not include any sensitive info.
    string error_message = 3;

    enum ErrorType {
      ERROR_TYPE_UNKNOWN = 0;
      TRANSIENT = 1;
      PERMANENT = 2;
    }
  }
}

message SketchAggregationMpc {
  // Stages of MPCs for combining sketches.
  enum SketchAggregationStage {
    // The computation stage is unknown. This is never set intentionally.
    SKETCH_AGGREGATION_STAGE_UNKNOWN = 0;
    // The computation is known but work has not started yet. Sketches required
    // for the computation stored at the local worker will be collected as part
    // of this stage.
    CREATED = 1;
    // The worker will add noise to the sketch.
    TO_ADD_NOISE = 2;
    // The primary worker is waiting for sketches from all the other MPC worker
    // nodes.
    WAIT_SKETCHES = 3;
    // The primary worker has received all the sketches needed to run the
    // computation. It will combine them together into a single sketch, i.e.
    // the first concatenated sketch.
    TO_APPEND_SKETCHES = 4;
    // The worker is waiting to receive a copy of the concatenated sketch from
    // the previous worker in the ring of workers. The primary worker is the
    // one to first send the concatenated sketch to the next worker, but it
    // does so before re-encrypting it's positional values. So the primary
    // Worker is waiting on a sketch from the Nth worker.
    WAIT_CONCATENATED = 5;
    // The non-primary worker re-encrypts its positional values in ths
    // concatenated sketch.
    TO_BLIND_POSITIONS = 6;
    // The primary worker re-encrypts the position values of the sketch and
    // joins them based on their re-encrypted positional values. Combining is
    // via the same key aggregation method to create the encrypted flag and
    // count tuples.
    TO_BLIND_POSITIONS_AND_JOIN_REGISTERS = 7;
    // The worker is waiting on its predecessor in the ring of workers for the
    // join sketch. The primary worker is the first to send the joined sketch,
    // but also the last to re-encrypt values in it.
    WAIT_FLAG_COUNTS = 8;
    // A non-primary worker decrypts the counts - which are the summed values
    // across all sketches for the same register value - and their flag values.
    TO_DECRYPT_FLAG_COUNTS = 9;
    // The primary worker computes the final reach and frequency.
    // This is the corollary of TO_DECRYPT_FLAG_COUNTS done at the non-primary
    // worker but the primary also uses a lookup table to map flags to
    // booleans and counts to actual integers, which are then used to in the
    // final reach and frequency estimations.
    TO_DECRYPT_FLAG_COUNTS_AND_COMPUTE_METRICS = 10;
    // The computation is done the worker can remove BLOBs that are no longer
    // needed.
    COMPLETED = 11;
  }
}
